---
title: Implementing Stripe-like Idempotency Keys in Postgres
published_at: 2017-09-20T11:46:10Z
location: Calgary
hook: Hardening services by identifying foreign state
  mutations and grouping local changes into atomic phases
  that can be restarted.
---

In the world of APIs, ***idempotency*** is an important
concept. An idempotent endpoint is one that can be called
any number of times while guaranteeing that the side
effects will occur only once. In a messy world where
clients and servers that may occasionally crash or have
their connections drop partway through a request, it's a
huge help in making systems more robust to failure. Clients
can simply keep retrying a request until they get a
definitive response.

Implementing a server so that requests to it are perfectly
idempotent isn't always easy. In endpoints that are _only_
mutating local state within an ACID database, it's possible
to get a robust and simple idempotency implementation by
mapping requests to transactions. I wrote about this more
simple case [in more detail a few weeks
ago](/http-transactions) (and if you can get away with just
that, do it).

## Idempotency with keys (#keys)

Endpoints that need to make foreign state changes
synchronously during the request are a little more
difficult. Say for example that we need to make a call to
Stripe to create a charge and we need to know in-band
whether that charge went through. To guarantee idempotency
on this type of endpoint we'll need to introduce an
***idempotency key***.

An idempotency key is a unique value that's generated by a
client and which is sent to an API along with a request.
The server stores the key to use for bookkeeping the stat
of that request on its end. If a request should fail
partway through, the client retries with _the same_
idempotency key value, and the server uses it to look up
the request's state and continue from where it left off.

``` sh
POST /v1/charges
Idempotency-Key: 0ccb7813-e63d-4377-93c5-476cb93038f3
...

amount=1000&currency=usd
```

Once the server knows that a request has definitively
finished by either succeeding or failing in a way that's
not recoverable, it stores the request's results onto its
internal idempotency key representation. If a client makes
another request with the same key, the server simply short
circuits it with the stored results.

Keys are not meant to be used as a permanent request
archive but rather as a mechanism for ensuring near-term
correctness. Servers should recycle them out of the system
beyond a horizon where they won't be of much use -- say 24
hours or so.

## Rocket Rides (#rocket-rides)

Let's look at how to design idempotency keys for an API by
building a reference implementation.

Our great dev relations team at Stripe has built an app
called [Rocket Rides][rocketrides] to demonstrate the use
of the Connect platform and other interesting parts of the
API. In Rocket Rides, users who are in a hurry share a ride
with a jetpack-certified pilot to get where they're going
_fast_. SOMA's gridlock traffic disappears into the
distance as they soar free through virgin skies. Travel is
a little more risky than Lyft, so make sure to pack an
extra parachute.

<p><img src="/assets/idempotency-keys/rocketrides-ios-ride.png" data-rjs="2"></p>

The [Rocket Rides repository][rocketrides] comes with a
simple server implementation, but software tends to grow
with time, so to be more representative of what a real
service with 15 engineers and half a dozen product owners
would look like, we're going to complicate things a little
bit by adding a few embellishments.

Our backend implementation will be called from the Rocket
Rides mobile app with an idempotency key. If a request
fails, the app will continue retrying the operation with
the same key, and our job as backend implementers is to
make sure that's safe. We'll be charging users' credit
cards as part of the request, and we absolutely can't take
the risk of charging them twice.

### The request lifecycle (#lifecycle)

When a new rides comes in we'll perform this set of
operations:

1. Insert an idempotency key record.
2. Create a ride record to track the ride that's about to
   happen.
3. Create an audit record referencing the ride.
4. **Make an API call to Stripe to charge the user for the
   ride** (here we're leaving our own stack, and this
   presents some risk).
5. Update the ride record with the created charge ID.
6. Send the user a receipt via email.
7. Update idempotency key with results.

!fig src="/assets/idempotency-keys/api-request.svg" caption="A typical API request to our embellished Rocket Rides backend."

### The entropy of production (#failure)

Most of the time we can expect every our Rocket Rides API
calls to go swimmingly, and every operation will succeed
without a problem. However, when we reach the scale of
thousands of API calls a day, we'll start to notice a few
problems appearing here and there; requests failing due to
poor cellular connectivity, API calls to Stripe failing
occasionally, or bad turbulence caused by moving at
supersonic speeds knocking users totally offline. After we
reach the scale of millions of API calls a day, we'll be
seeing these sorts of things happening all the time.

Let's look at a few examples of things that can go wrong:

* Inserting the idempotency key or ride record could fail
  due to a constraint violation or a database connectivity
  problem.
* Our call to Stripe could time out, leaving it unclear
  whether our charge when through or not.
* Contacting Mailgun to send the receipt could fail,
  leaving the user with a credit card charge but no formal
  notification of the transaction.
* The client could disconnect, cancelling the operation
  midway through.

## Foreign state mutations (#foreign-state)

To shore up our backend, it's key to identify where we're
making ***foreign state mutations***; that is, calling out
and manipulating data on another system. This might be
creating a charge on Stripe, adding a DNS record, or
sending an email.

Some foreign state mutations are idempotent by nature (e.g.
adding a DNS record), some are not idempotent but can be
made idempotent with the help of an idempotency key (e.g.
charge on Stripe, sending an email), and some operations
are not idempotent, most often because a foreign service
hasn't designed them that way and doesn't provide a
mechanism like an idempotency key.

The reason that the local vs. foreign distinction matters
is that unlike a local set of operations where we can just
roll back a result that we didn't like, once we make our
first foreign state mutation, we're committed one way or
another [1]. We've pushed data into a system beyond our own
boundaries and we shouldn't lose track of it.

### Between any two systems (#two-systems)

We're using an API call to Stripe as a common example, but
remember that even foreign calls within your own
infrastructure count! It's tempting to treat emitting
records to Kafka as part of atomic operations because they
have such a high success rate that they feels like they
are. But they're absolutely not, and should be treated like
any other foreign state mutation.

## Atomic phases (#atomic-phases)

An ***atomic phase*** is a set of local state mutations
that occur in transactions _between_ foreign state
mutations. We say that they're atomic because we can use an
ACID-compliant database like Postgres to guarantee that
either all of them will occur, or none will.

Atomic phases should be safely committed _before_
initiating any foreign state mutation. If the call fails,
our local state will still have a record of it happening
that we can use to retry the operation.

### Savepoints (#savepoints)

A ***savepoint*** is a name of a check point that we get to
after having successfully executed any atomic phase _or_
foreign state mutation. It's purpose is to allow a retrying
request to jump back to the point in the lifecycle where
the last attempt failed.

For convenience, we're going to store the name of the
savepoint reached right onto idempotency key relation that
we'll build. All requests will initially get a savepoint of
`started`, and after any request is complete (again,
through either a success or definitive error) it'll be
assigned a savepoint of `finished`. When in an atomic
phase, the transition to a new savepoint should be
committed as part of that phase's transaction so that it's
part of the atomic operation as well.

## Background jobs and job staging (#background-jobs)

In-band foreign state mutations make a request slower and
more difficult to reason about, so they should be avoided
when possible. In many cases it's possible to defer this
type of work to after the request is complete by sending it
to a background job queue.

To re-use the examples above, a charge to Stripe probably
_can't_ be deferred to the background because we want to
know whether it succeeded right away (and deny the request
if not). Sending an email _can_ and should be sent to the
background.

By using a [_transactionally-staged job
drain_](/job-drain), we can hide jobs from workers until
we've confirmed that they're ready to be worked by
isolating them in a transaction. This also means that the
background work becomes part of an atomic phase and greatly
simplifies the operational. Work should always be offloaded
to background queues when possible.

## Hardening Rocket Rides for interstellar travel (#interstellar)

Now that we've covered a few key concepts, we're ready to
shore up our alternative Rocket Rides backend so that it's
resilient against any kind of failure imaginable. Let's put
together the basic schema, break the lifecycle up into
atomic phases, and then design a simple implementation that
will recover from failures.

### The idempotency key relation (#idempotency-key)

`locked_at`
`params`
`savepoint`

### Other schema (#other-schema)

### Designing atomic phases (#rocket-rides-phases)

!fig src="/assets/idempotency-keys/atomic-phases.svg" caption="API request to Rocket Rides broken into foreign state mutations and atomic phases."

### The jailbreaker (#jailbreaker)

``` sql
UPDATE idempotency_keys
SET locked_at = NULL
WHERE savepoint != 'finished'
  AND locked_at < now() - '2 minutes'::interval;
```

### Stretch feature: the completionist (#completionist)

One problem with this implementation is we're reliant on
clients to push indeterminate requests to completion.
Usually clients are more than willing to do this, but there
can be cases where a client starts working, never quite
finishes, and drops forever.

A stretch goal is implement a ***completionist*** worker.
Its only job is to find requests that look like they never
finished to satisfaction and which it doesn't look like
clients will be coming back for, and push them through.

It doesn't even have to have special knowledge about how
the stack is implemented. It just needs to know how to read
idempotency keys and have an internal authentication path
that allows it to retry anyone's request.

``` ruby
loop do
end
```

## Murphy in action (#murphys-law)

Now let's look at a perfectly degenerate case.

## Non-idempotent foreign state mutations (#non-idempotent)

If we know that a foreign state mutation is an idempotent
operation or it supports an idempotency key (like Stripe
does), we know that it's safe to retry any failures that we
see.

Unfortunately, not every service will make this guarantee.
If we try to make a non-idempotent foreign state mutation
and we see a failure, we may have to persist this operation
as permanently errored. In many cases we won't know whether
it's safe to retry or not, and we'll have to take the
conservative route and fail the operation.

The exception is if we got an error back from the
non-idempotent API, but one that tell us explicitly that
it's okay to retry. Indeterminate errors like a connection
reset or timeout will have to be marked as failed.

This is why you should implement idempotency and/or
idempotency keys on all your services!

[1] There is one caveat that it may be possible to
implement [two-phase commit][2pc] between a system and all
other systems where it performs foreign state mutations.
This would allow distributed rollbacks, but is complex and
time-consuming enough to implement that it's rarely seen
with any kind of ubiquity in real software environments.

[2pc]: https://en.wikipedia.org/wiki/Two-phase_commit_protocol
[idempotency]: https://stripe.com/blog/idempotency
[rocketrides]: https://github.com/stripe/stripe-connect-rocketrides
