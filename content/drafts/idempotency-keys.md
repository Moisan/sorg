---
title: Implementing Stripe-like Idempotency Keys in Postgres
published_at: 2017-09-20T11:46:10Z
location: Calgary
hook: Hardening services by identifying foreign state
  mutations and grouping local changes into atomic phases
  that can be restarted.
---

In the world of APIs, ***idempotency*** is an important
concept. An idempotent endpoint is one that can be called
any number of times while guaranteeing that the side
effects will occur only once. In a messy world where
clients and servers that may occasionally crash or have
their connections drop partway through a request, it's a
huge help in making systems more robust to failure. Clients
can simply keep retrying a request until they get a
definitive response.

Implementing a server so that requests to it are perfectly
idempotent isn't always easy. In endpoints that are _only_
mutating local state within an ACID database, it's possible
to get a robust and simple idempotency implementation by
mapping requests to transactions. I wrote about this more
simple case [in more detail a few weeks
ago](/http-transactions) (and if you can get away with just
that, do it).

## Idempotency with keys (#keys)

Endpoints that need to make foreign state changes
synchronously during the request are a little more
difficult. Say for example that we need to make a call to
Stripe to create a charge and we need to know in-band
whether that charge went through. To guarantee idempotency
on this type of endpoint we'll need to introduce an
***idempotency key***.

An idempotency key is a unique value that's generated by a
client and which is sent to an API along with a request.
The server stores the key to use for bookkeeping the stat
of that request on its end. If a request should fail
partway through, the client retries with _the same_
idempotency key value, and the server uses it to look up
the request's state and continue from where it left off.

``` sh
POST /v1/charges
Idempotency-Key: 0ccb7813-e63d-4377-93c5-476cb93038f3
...

amount=1000&currency=usd
```

Once the server knows that a request has definitively
finished by either succeeding or failing in a way that's
not recoverable, it stores the request's results onto its
internal idempotency key representation. If a client makes
another request with the same key, the server simply short
circuits it with the stored results.

Keys are not meant to be used as a permanent request
archive but rather as a mechanism for ensuring near-term
correctness. Servers should recycle them out of the system
beyond a horizon where they won't be of much use -- say 24
hours or so.

## Rocket Rides (#rocket-rides)

Let's look at how to design idempotency keys for an API by
building a reference implementation.

Our great dev relations team at Stripe has built an app
called [Rocket Rides][rocketrides] to demonstrate the use
of the Connect platform and other interesting parts of the
API. In Rocket Rides, users who are in a hurry share a ride
with a jetpack-certified pilot to get where they're going
_fast_. SOMA's gridlock traffic disappears into the
distance as they soar free through virgin skies. Travel is
a little more risky than Lyft, so make sure to pack an
extra parachute.

<p><img src="/assets/idempotency-keys/rocketrides-ios-ride.png" data-rjs="2"></p>

The [Rocket Rides repository][rocketrides] comes with a
simple server implementation, but software tends to grow
with time, so to be more representative of what a real
service with 15 engineers and half a dozen product owners
would look like, we're going to complicate things a little
bit by adding a few embellishments.

Our backend implementation will be called from the Rocket
Rides mobile app with an idempotency key. If a request
fails, the app will continue retrying the operation with
the same key, and our job as backend implementers is to
make sure that's safe. We'll be charging users' credit
cards as part of the request, and we absolutely can't take
the risk of charging them twice.

### The request lifecycle (#lifecycle)

When a new rides comes in we'll perform this set of
operations:

1. Insert an idempotency key record.
2. Create a ride record to track the ride that's about to
   happen.
3. Create an audit record referencing the ride.
4. **Make an API call to Stripe to charge the user for the
   ride** (here we're leaving our own stack, and this
   presents some risk).
5. Update the ride record with the created charge ID.
6. Send the user a receipt via email.
7. Update idempotency key with results.

!fig src="/assets/idempotency-keys/api-request.svg" caption="A typical API request to our embellished Rocket Rides backend."

### The entropy of production (#failure)

Most of the time we can expect every our Rocket Rides API
calls to go swimmingly, and every operation will succeed
without a problem. However, when we reach the scale of
thousands of API calls a day, we'll start to notice a few
problems appearing here and there; requests failing due to
poor cellular connectivity, API calls to Stripe failing
occasionally, or bad turbulence caused by moving at
supersonic speeds knocking users totally offline. After we
reach the scale of millions of API calls a day, we'll be
seeing these sorts of things happening all the time.

Let's look at a few examples of things that can go wrong:

* Inserting the idempotency key or ride record could fail
  due to a constraint violation or a database connectivity
  problem.
* Our call to Stripe could time out, leaving it unclear
  whether our charge when through or not.
* Contacting Mailgun to send the receipt could fail,
  leaving the user with a credit card charge but no formal
  notification of the transaction.
* The client could disconnect, cancelling the operation
  midway through.

## Foreign state mutations (#foreign-state)

To shore up our backend, it's key to identify where we're
making ***foreign state mutations***; that is, calling out
and manipulating data on another system. This might be
creating a charge on Stripe, adding a DNS record, or
sending an email.

Some foreign state mutations are idempotent by nature (e.g.
adding a DNS record), some are not idempotent but can be
made idempotent with the help of an idempotency key (e.g.
charge on Stripe, sending an email), and some operations
are not idempotent, most often because a foreign service
hasn't designed them that way and doesn't provide a
mechanism like an idempotency key.

The reason that the local vs. foreign distinction matters
is that unlike a local set of operations where we can just
roll back a result that we didn't like, once we make our
first foreign state mutation, we're committed one way or
another [1]. We've pushed data into a system beyond our own
boundaries and we shouldn't lose track of it.

### Between any two systems (#two-systems)

We're using an API call to Stripe as a common example, but
remember that even foreign calls within your own
infrastructure count! It's tempting to treat emitting
records to Kafka as part of atomic operations because they
have such a high success rate that they feels like they
are. But they're absolutely not, and should be treated like
any other foreign state mutation.

## Atomic phases (#atomic-phases)

An ***atomic phase*** is a set of local state mutations
that occur in transactions _between_ foreign state
mutations. We say that they're atomic because we can use an
ACID-compliant database like Postgres to guarantee that
either all of them will occur, or none will.

Atomic phases should be safely committed _before_
initiating any foreign state mutation. If the call fails,
our local state will still have a record of it happening
that we can use to retry the operation.

### Recovery points (#recovery-points)

A ***recovery point*** is a name of a check point that we
get to after having successfully executed any atomic phase
_or_ foreign state mutation. Its purpose is to allow a
request that's being retried to jump back to the point in
the lifecycle just before the last attempt failed.

For convenience, we're going to store the name of the
recovery point reached right onto idempotency key relation
that we'll build. All requests will initially get a
recovery point of `started`, and after any request is
complete (again, through either a success or definitive
error) it'll be assigned a recovery point of `finished`.
When in an atomic phase, the transition to a new recovery
point should be committed as part of that phase's
transaction so that it's part of the atomic operation as
well.

## Background jobs and job staging (#background-jobs)

In-band foreign state mutations make a request slower and
more difficult to reason about, so they should be avoided
when possible. In many cases it's possible to defer this
type of work to after the request is complete by sending it
to a background job queue.

To re-use the examples above, a charge to Stripe probably
_can't_ be deferred to the background because we want to
know whether it succeeded right away (and deny the request
if not). Sending an email _can_ and should be sent to the
background.

By using a [_transactionally-staged job
drain_](/job-drain), we can hide jobs from workers until
we've confirmed that they're ready to be worked by
isolating them in a transaction. This also means that the
background work becomes part of an atomic phase and greatly
simplifies the operational. Work should always be offloaded
to background queues when possible.

## Hardening Rocket Rides for interstellar travel (#interstellar)

Now that we've covered a few key concepts, we're ready to
shore up our alternative Rocket Rides backend so that it's
resilient against any kind of failure imaginable. Let's put
together the basic schema, break the lifecycle up into
atomic phases, and then design a simple implementation that
will recover from failures.

### The idempotency key relation (#idempotency-key)

Let's design a Postgres schema for idempotency keys in our
app:

``` sql
CREATE TABLE idempotency_keys (
    id              BIGSERIAL   PRIMARY KEY,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    idempotency_key TEXT        NOT NULL
        CHECK (char_length(idempotency_key) <= 100),
    locked_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- parameters of the incoming request
    request_params  JSONB       NOT NULL,

    -- for finished requests, stored status code and body
    response_code   INT         NULL,
    response_body   JSONB       NULL,

    recovery_point  TEXT        NOT NULL
        CHECK (char_length(recovery_point) <= 50),
    user_id         BIGINT      NOT NULL
);

CREATE UNIQUE INDEX idempotency_keys_user_id_idempotency_key
    ON idempotency_keys (user_id, idempotency_key);
```

There are a few notable fields here:

* `idempotency_key`: This is the user-specified idempotency
  key. It's good practice to send something with good
  randomness like a UUID, but not necessarily required. We
  constraint the field's length so that nobody sends us
  anything too crazy.

    We've made `idempotency_key` unique, but across
    `(user_id, idempotency_key)` so that it's possible to
    have the same idempotency key for different requests as
    long as it's across different accounts.

* `locked_at`: A field that indicates whether this
  idempotency key is actively being worked. The first API
  request that creates the key will lock it automatically,
  but subsequent retries will also set it to make sure that
  they're the only request doing the work.

* `params`: The input parameters of the request. This is
  stored mostly so that we can error if the user sends two
  requests with the same idempotency key but with different
  parameters, but can also be used for our own backend to
  push unfinished requests to completion (see [the
  completionist](#completionist) below).

* `recovery_point`: A text label for the last phase
  completed for the idempotent request (see [recovery
  points](#recovery-points) above). Gets an initial value
  of `started` and is set to `finished` when the request is
  considered to be complete.

### Other schema (#other-schema)

Recall our target API lifecycle for Rocket Rides from
above.

!fig src="/assets/idempotency-keys/api-request.svg" caption="A typical API request to our embellished Rocket Rides backend."

Let's bring up Postgres relations for everything else we'll
need to build this app including audit records, rides, and
users. Given that we aim to maximize reliability, we'll try
to follow database best practices and use `NOT NULL`,
unique, and foreign key constraints wherever we can.

``` sql
--
-- A relation to hold records for every user of our app.
--
CREATE TABLE users (
    id                 BIGSERIAL       PRIMARY KEY,
    email              TEXT            NOT NULL UNIQUE
        CHECK (char_length(email) <= 255),

    -- Stripe customer record with an active credit card
    stripe_customer_id TEXT            NOT NULL UNIQUE
        CHECK (char_length(stripe_customer_id) <= 50)
);

--
-- Now that we have a users table, add a foreign key
-- constraint to idempotency_keys which we created above.
--
ALTER TABLE idempotency_keys
    ADD CONSTRAINT idempotency_keys_user_id_fkey
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE RESTRICT;

--
-- A relation that hold audit records that can help us piece
-- together exactly what happened in a request if necessary
-- after the fact. It can also, for example, be used to
-- drive internal security programs tasked with looking for
-- suspicious activity.
--
CREATE TABLE audit_records (
    id                 BIGSERIAL       PRIMARY KEY,

    -- action taken, for example "created"
    action             TEXT            NOT NULL
        CHECK (char_length(action) <= 50),

    created_at         TIMESTAMPTZ     NOT NULL DEFAULT now(),
    data               JSONB           NOT NULL,
    origin_ip          CIDR            NOT NULL,

    -- resource ID and type, for example "ride" ID 123
    resource_id        BIGINT          NOT NULL,
    resource_type      TEXT            NOT NULL
        CHECK (char_length(resource_type) <= 50),

    user_id            BIGINT          NOT NULL
        REFERENCES users ON DELETE RESTRICT
);

--
-- A relation representing a single ride by a user.
-- Notably, it holds the ID of a successful charge to
-- Stripe after we have one.
--
CREATE TABLE rides (
    id                 BIGSERIAL       PRIMARY KEY,
    created_at         TIMESTAMPTZ     NOT NULL DEFAULT now(),

    -- Store a reference to the idempotency key so that we can recover an
    -- already-created ride. Note that idempotency keys are not stored
    -- permanently, so make sure to SET NULL when a referenced key is being
    -- reaped.
    idempotency_key_id BIGINT          UNIQUE
        REFERENCES idempotency_keys ON DELETE SET NULL,

    -- origin and destination latitudes and longitudes
    origin_lat         NUMERIC(13, 10) NOT NULL,
    origin_lon         NUMERIC(13, 10) NOT NULL,
    target_lat         NUMERIC(13, 10) NOT NULL,
    target_lon         NUMERIC(13, 10) NOT NULL,

    -- ID of Stripe charge like ch_123; NULL until we have one
    stripe_charge_id   TEXT            UNIQUE
        CHECK (char_length(stripe_charge_id) <= 50),

    user_id            BIGINT          NOT NULL
        REFERENCES users ON DELETE RESTRICT
);

CREATE INDEX rides_idempotency_key_id
    ON rides (idempotency_key_id)
    WHERE idempotency_key_id IS NOT NULL;

--
-- A relation that holds our transactionally-staged jobs
-- (see "Background jobs and job staging" above).
--
CREATE TABLE staged_jobs (
    id                 BIGSERIAL       PRIMARY KEY,
    job_name           TEXT            NOT NULL,
    job_args           JSONB           NOT NULL
);
```

### Designing atomic phases (#rocket-rides-phases)

!fig src="/assets/idempotency-keys/atomic-phases.svg" caption="API request to Rocket Rides broken into foreign state mutations and atomic phases."

First handle idempotency keys:

From now on we're going to build a looping construct so we
can advance through the phases of a request:

``` ruby
```

Creating a ride and ride audit record:

### A stateful implementation (#stateful)

``` ruby
```

### The jailbreaker (#jailbreaker)

``` sql
UPDATE idempotency_keys
SET locked_at = NULL
WHERE savepoint != 'finished'
  AND locked_at < now() - '2 minutes'::interval;
```

### The reaper (#reaper)

Reaps dead keys.

### Stretch feature: the completionist (#completionist)

One problem with this implementation is we're reliant on
clients to push indeterminate requests to completion.
Usually clients are more than willing to do this, but there
can be cases where a client starts working, never quite
finishes, and drops forever.

A stretch goal is implement a ***completionist*** worker.
Its only job is to find requests that look like they never
finished to satisfaction and which it doesn't look like
clients will be coming back for, and push them through.

It doesn't even have to have special knowledge about how
the stack is implemented. It just needs to know how to read
idempotency keys and have an internal authentication path
that allows it to retry anyone's request.

``` ruby
loop do
end
```

## Murphy in action (#murphys-law)

Now let's look at a perfectly degenerate case.

## Non-idempotent foreign state mutations (#non-idempotent)

If we know that a foreign state mutation is an idempotent
operation or it supports an idempotency key (like Stripe
does), we know that it's safe to retry any failures that we
see.

Unfortunately, not every service will make this guarantee.
If we try to make a non-idempotent foreign state mutation
and we see a failure, we may have to persist this operation
as permanently errored. In many cases we won't know whether
it's safe to retry or not, and we'll have to take the
conservative route and fail the operation.

The exception is if we got an error back from the
non-idempotent API, but one that tell us explicitly that
it's okay to retry. Indeterminate errors like a connection
reset or timeout will have to be marked as failed.

This is why you should implement idempotency and/or
idempotency keys on all your services!

[1] There is one caveat that it may be possible to
implement [two-phase commit][2pc] between a system and all
other systems where it performs foreign state mutations.
This would allow distributed rollbacks, but is complex and
time-consuming enough to implement that it's rarely seen
with any kind of ubiquity in real software environments.

## Beyond APIs (#beyond-apis)

Use idempotency keys in `<input type="hidden">` to control
multiple form submissions.

[2pc]: https://en.wikipedia.org/wiki/Two-phase_commit_protocol
[idempotency]: https://stripe.com/blog/idempotency
[rocketrides]: https://github.com/stripe/stripe-connect-rocketrides
